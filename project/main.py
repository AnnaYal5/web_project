"""
Ваше завдання полягає у створенні веб-сайту для купівлі та продажу бувших у вжитку речей.
Цей проект передбачає реалізацію повнофункціонального веб-додатку, який забезпечуватиме користувачам можливість
перегляду, додавання та купівлі товарів, а також ведення комунікацій між покупцями та продавцями через інтегрований чат.
Частина 1
Реалізувати систему реєстрації та входу для користувачів, використовуючи протокол OAuth2.
Кроки:
- Визначення моделей Pydantic для реєстрації та входу з необхідними полями (наприклад, ім'я, електронна адреса, пароль).
- Розробка ендпоінта для реєстрації нових користувачів, включаючи валідацію даних та збереження інформації в базі даних.
- Використання безпечних методів хешування (наприклад, bcrypt) для збереження паролів.
- Імплементація логіки для входу користувачів, перевірки облікових даних та генерації JWT,
    що використовується для подальшої автентифікації запитів.
- Забезпечення захисту ендпоінтів і вимога автентифікації через JWT для доступу до захищених ресурсів.

Частина 2
Розробити функціонал, який дозволяє користувачам переглядати оголошення та фільтрувати їх за різними критеріями,
такими як категорії, ціни, та інші характеристики.
Кроки
- Створення моделей Pydantic, які відображають структуру даних оголошень.
- Розробка ендпоінтів для отримання списку оголошень з бази даних.
- Додавання можливості фільтрації оголошень за різними параметрами (категорія, ціна, тощо).
 Це може включати створення динамічних SQL-запитів або використання Elasticsearch для розширеного пошуку.
- Впровадження пагінації для ефективного перегляду великої кількості оголошень.
- Переконатися, що фільтрація працює коректно та ефективно на різних наборах даних.

Частина 3
Для реалізації функціоналу додавання нових оголошень у ваш проект, потрібно створити інтерфейс,
який дозволяє користувачам вносити інформацію про товари, які вони хочуть продати.
Створіть форму на фронтенді, де користувачі можуть ввести деталі товару, такі як назва, опис, ціна, категорія.
Форма також має включати можливість завантажувати фотографії товару.
На бекенді використайте FastAPI для створення API ендпоінтів, які приймають дані форми та зображення.
Ви можете використовувати бібліотеку FastAPI для обробки завантажених файлів і збереження їх на сервері.
Використайте SQLAlchemy або іншу ORM для збереження інформації про оголошення у базі даних.
Кожне оголошення має бути пов'язане з користувачем, який його додав.
Перед збереженням даних у базі даних виконайте валідацію за допомогою моделей Pydantic, щоб переконатися,
що дані відповідають очікуваним форматам та типам.
Після додавання оголошень, вони повинні бути доступні для перегляду іншими користувачами на платформі.

Частина 4
Визначте моделі для збереження інформації про користувачів та товари в базі даних.
Моделі повинні містити всі необхідні поля, такі як ім'я користувача, електронна пошта,
пароль для користувачів та назва, опис, ціна, категорія для товарів.
Використайте SQLAlchemy, для створення та управління таблицями у базі даних.
Для переконання в коректності даних, що надходять від користувачів, використайте моделі Pydantic.
Реалізуйте функціонал для збереження фотографій товарів, які завантажуються користувачами.
Фотографії можуть бути збережені локально на сервері.
У вашому FastAPI додатку створіть ендпоінти для обробки запитів на реєстрацію, вхід, додавання товарів та їх перегляду.
Кожен ендпоінт повинен використовувати відповідні моделі Pydantic для валідації вхідних даних перед їх обробкою.

Частина 5
Створіть систему чату, яка дозволить покупцям та продавцям в реальному часі обмінюватися повідомленнями.
Використайте технологію WebSocket, яка інтегрується в FastAPI, для створення постійного з'єднання між сервером та клієнтами.
На фронтенді створіть користувацький інтерфейс для чату.
Це може включати вікно чату, де користувачі можуть бачити історію повідомлень та вводити нові повідомлення.
На бекенді реалізуйте логіку для прийому та відправлення повідомлень через WebSocket.
Це включає в себе відкриття з'єднань, обробку вхідних повідомлень від користувачів та відправлення відповідей.
Інтегруйте систему зберігання, щоб зберегти історію чату між користувачами.
Це може бути зроблено через базу даних, де кожне повідомлення зберігається
з інформацією про відправника, отримувача та час відправлення.
Забезпечте, щоб лише автентифіковані користувачі могли використовувати чат.
Використайте систему автентифікації OAuth2 для перевірки користувачів, які намагаються встановити з'єднання WebSocket.

Частина 6
Використайте бібліотеки Swagger та ReDoc, щоб автоматично генерувати документацію на основі вашого коду.
Для кожного ендпоінта API вкажіть детальний опис, включаючи інформацію про параметри запиту,
формат відповіді та можливі статус-коди HTTP.
Додайте приклади використання API, що демонструють реальні сценарії викликів API.
Це може включати приклади запитів та відповідей у форматі JSON.
Використовуйте анотації та коментарі у вашому коді FastAPI для додавання додаткових деталей до документації.
Це може включати пояснення до параметрів, винятків, які можуть виникнути, та інших важливих деталей.
Налаштуйте візуальний вигляд Swagger UI або ReDoc,
щоб зробити документацію більш зручною та привабливою для користувачів.
"""
from fastapi import FastAPI, HTTPException, UploadFile, File, Form, Depends
from passlib.context import CryptContext
from starlette.datastructures import UploadFile

from models.auth_models import User, Ad, AdBase
from typing import Optional
from fastapi_pagination import Page, paginate, add_pagination
from fastapi_pagination.limit_offset import LimitOffsetPage
import os
from uuid import uuid4
import shutil


app = FastAPI()

UPLOAD_F ="uploads"
os.makedirs(UPLOAD_F, exist_ok=True)


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


fake_db = {}
ads_db = {}

@app.post("/register")
def register(user: User):
    if user.username in fake_db:
        raise HTTPException(status_code=400, detail="User already registered")
    hashed_password = pwd_context.hash(user.password)
    fake_db[user.username] = {
        "email": user.email,
        "password": hashed_password
    }
    return {"massage": "User registered successfully"}

@app.post("/login")
def login(user: User):
    db_user = fake_db.get(user.username)
    if not db_user or not pwd_context.verify(user.password, db_user["hashed_password"]):
        raise HTTPException(status_code=401, detail="Invalid username or password")

    return {"massage": "Login successful"}


@app.post("/announcement")
def create_ad(ad:Ad):
    ads_db.append(ad)
    return {"massage": "Ad created successfully"}
#Розробка ендпоінтів для отримання списку оголошень з бази даних.

@app.get("/ads/", response_model=LimitOffsetPage[Ad])
def get_ads(
    category: Optional[str] = None,
    min_price: Optional[float] = None,
    max_price: Optional[float] = None

):
    filtered_ads = ads_db

    if category:
        filtered_ads = [ad for ad in filtered_ads if ad.category == category]
    if min_price is not None:
        filtered_ads = [ad for ad in filtered_ads if ad.price >= min_price]
    if max_price is not None:
        filtered_ads = [ad for ad in filtered_ads if ad.price <= max_price]

    return paginate(filtered_ads)
#Додавання можливості фільтрації оголошень за різними параметрами (категорія, ціна, тощо).


add_pagination(app)


@app.post("/createads")
async def create_announcement(
    title: str,
    image: UploadFile = Form(...),
    description: str = Form(''),
    price: float = Form(...),
    category: str = Form("")
):

   file_name = f"{uuid4().hex}_{image.filename}"  # створюється ім'я файлу
   file_path = os.path.join(UPLOAD_F, file_name)  # повний шлях

   with open(file_path, "wb") as f:
       shutil.copyfileobj(image.file, f)

   ad = {
        "title":  title,
        "description": description,
        "price": price,
        "category": category,
        "image": file_path

       }
   ads_db.append(ad)

   return { "ad": ad }






# if __name__ == '__main__':
#     uvicorn.run(app)

